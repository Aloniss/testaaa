---
title: "Trabajo 1 Planificación Territorial"
---

Esta es una guía detallada de como poder realizar el trabajo práctico N°1 del curso Planificación Territorial.

El objetivo es ... jardines ... ciudad en 15 minutos ... ver cuanto se demora a pie.

# Organización {#sec-organizacion}

::: {.callout-important}
Este informe esta pensado en ejecutarse dentro de una carpeta que contenga el trabajo (por ejemplo, *trabajo1*) y **DENTRO DE ESTA** una carpeta llamada **datos**, la cual contendrá todas las capas para el análisis.
:::

A modo de ejemplo, el trabajo debería tener un orden así

```
Carpeta_del_trabajo/
├── scprit.r
└── datos/
    ├── DEM Los Ríos.tif
    ├── Jardines Junji.shp
    ├── Jardines Integra.shp
    ├── Limite Urbano Censal Valdivia.gpkp
    └── Unidad Vecinal Valdivia.gpkp
```

**En mi caso, la estructura es así**

```
C:/uni/oit/trabajo1/
├── scprit.r
└── datos/
    ├── dem_tif.tif
    ├── layer_jardines_infantiles_junji_2024_20240619120021.shp
    ├── layer_jardines_infantiles_fundacion_integra_20231112011653.shp
    ├── LUC_Valdivia.gpkg
    └── Unidad_vecinal_Valdi.gpkg
```

::: {.callout-note}
Cabe resaltar que cada usuari@ puede tener el orden que quiera, aquí tendrá este orden para una mejor reproducibilidad.
:::

# Datos

## Obtención de Datos

Los datos con los que se trabajará serán los siguientes:

-   DEM Alos Palsar: El Modelo Digital de Elevación que fue provisto en la clase. Sin embargo, puede descargarse desde [IDE Chile](https://www.geoportal.cl/geoportal/catalog/35432/DEM%20Alos%20Palsar%20Regi%C3%B3n%20de%20Los%20R%C3%ADos).

-   Límite Urbano Censal de Valdivia: Provisto en Clase.

-   Unidad Vecinal de Valdivia: Provisto en Clase.

-   Jardines Infantiles JUNJI: Descargado desde [IDE Chile](https://www.geoportal.cl/geoportal/catalog/34965/Jardines%20Infantiles%20JUNJI).

-   Jardines Infantiles Fundación Integra: Descargado desde [IDE Chile](https://www.geoportal.cl/geoportal/catalog/35001/Jardines%20Infantiles%20Fundaci%C3%B3n%20Integra).

::: {.callout-warning}
Aquí debemos evaluar si incluir datos de jardines privados, aunque está abierto a discusión.
:::

## Pre Procesamiento

### Librerías

Las librerías serán las mismas que se han visto en las clases. Son las siguientes:

```{r}
#| message: false
#| warning: false

library(dplyr) # <1>
library(ggplot2) # <1>
library(dodgr) # <2>
library(sf) # <3>
library(h3) # <4>
library(terra) # <5>
library(osmdata) # <6>
library(tmap) # <7>
```

1. Paquete para el manejo de datos. Personalmente prefiero cargar `tidyverse` ya que incluye otras librerías importantes como `lubridate` (para manejo de fechas) o `ggplot2`, para visualización.
2. Librería para analizar teoría de grafos. Encontré una guía introductoria (pero en inglés) [aquí](https://mathigon.org/course/graph-theory/introduction).
3. Librería que maneja los datos espaciales. Piensen los datos vectoriales como una tabla excel con atributos (como *Nombre*, *Descripción*, *Region*, *etc*.) y que al final tiene una columna de geometría (usualmente llamada `.geo` o `geometry`), la que provee a un dato de una "forma". 
4. Paquete para hacer los hexágonos.
5. Librería para manejar datos ráster. 
6. Para obtener datos de elevación y de *Open Street Map* (OSM).
7. Esta es para hacer cartografía, tal como se hace en QGIS. Pero con esta librería se hacen los mapas interactivos también.


::: {.callout-note}
Se puede hacer click en los números para una "selección" visual.
:::

```{r}
#| message: false
#| warning: false
#| echo: false

library(kableExtra)
```

### Situar el Ambiente

Antes de comenzar, dentro del script deberemos *setear* el ambiente hacia donde están los datos. Revisar @sec-organizacion para seguir el siguiente ejemplo.

Si el script (`scprit.r`) se encuentra dentro de la carpeta *trabajo1*, **pero no dentro** de la carpeta *datos*
```{r}
#| eval: false

setwd("datos/")
```

Si el script **no se encuentra** dentro de la carpeta *trabajo1*, se deberá hacer alusión a la **ruta completa** de los datos. En mi caso:

```{r}
#| eval: false

setwd("C:/uni/oit/t1/datos/")
```

Si el script se encuentra *dentro* de la carpeta datos, en teoría no debería hacerse nada.

::: {.callout-warning}
Windows indica las rutas de las carpetas con el *backslash* (`\`) pero R nos los maneja bien. Para indicar la ruta de una carpeta se debe cambiar este símbolo por un *slash* (`/`).
:::

### Cargar las capas

Una vez seteados en la carpeta correcta, podemos cargar todas las capas y trabajar en base a eso. Para los datos `.shp` se deberá ocupar `st_read()` desde el paquete `sf` y para datos raster la función `rast()` de `terra`.

```{r}
#| eval: false
#| include: true

jardinJunji <- st_read("layer_jardines_infantiles_junji_2024_20240619120021.shp")

jardinIntegra <- st_read("layer_jardines_infantiles_fundacion_integra_20231112011653.shp")

dem <- rast("dem_tif.tif")

```

```{r}
#| eval: true
#| echo: false
#| output: false

jardinJunji <- st_read("datos/layer_jardines_infantiles_junji_2024_20240619120021.shp")

jardinIntegra <- st_read("datos/layer_jardines_infantiles_fundacion_integra_20231112011653.shp")

dem <- rast("c:/uni/oit/dem_tif.tif")

```

En el caso de las capas de LUC y Unidad Vecinal de Valdivia, que se encuentran en formato `.gpkg`, se deberá indicar un argumento extra dentro de `st_read()`. Esto ya que el formato *geopackage* es un contenedor que puede almacenar múltiples capas y otros datos relacionados, todo en un único archivo. Es por esto que hay que indicar que capa se quiere acceder. Para ver el listado de capas que tiene un `.gpkg`, se puede usar la funcion `st_layers()`:

```{r}
#| eval: false
#| include: true

st_layers("LUC_Valdivia.gpkg")
```

```{r}
#| eval: true
#| echo: false

print(st_layers("datos/LUC_Valdivia.gpkg"))
```

Podemos ver que el archivo `LUC_Valdivia.gpkg` tiene solo una capa, llamada `luc_valdivia` (a través del campo `layer_name`). En el caso de las unidades vecinales

```{r}
#| eval: false
#| include: true

st_layers("Unidad_vecinal_Valdi.gpkg")
```

```{r}
#| eval: true
#| echo: false

print(st_layers("datos/Unidad_vecinal_Valdi.gpkg"))
```

la capa se llama `unidad_vecinal`. Con esta información podemos cargar correctamente los datos:

```{r}
#| eval: false
#| include: true

lucVald <- st_read("LUC_Valdivia.gpkg",
                   layer = "luc_valdivia")


uvVald <- st_read("Unidad_vecinal_Valdi.gpkg",
                  layer = "unidad_vecinal")
```

```{r}
#| eval: true
#| echo: false
#| output: false

lucVald <- st_read("datos/LUC_Valdivia.gpkg",
                    layer = "luc_valdivia")


uvVald <- st_read("datos/Unidad_vecinal_Valdi.gpkg",
                    layer = "unidad_vecinal")
```


### Proyección

Para poder hacer el informe, debemos tener en consideración la proyección de las capas. Para que el flujo funcione, **TODAS** las capas deben estar en `EPSG:4326`, el cual corresponder a la proyección mundial *WGS 84*, el cual se compone de *latitud* y *longitud* (en grados).

##### Datos Vectoriales

Para ver el CRS de un dato vectorial se podría ocupar la función `st_crs()`, el cual mostrará *toda* la información de la proyección.

```{r}
st_crs(uvVald)
```

Sin embargo, como esto muestra toda la información, accederemos únicamente al *EPSG* accediendo con el signo peso (`$`).

```{r}
st_crs(uvVald)$epsg
```

Esta capa ya se encuentra en el sistema de coordenadas. De querer confirmar esto, se puede comparar con el operador de igualdad (`==`). Este operador compara si dos valores son iguales. Devuelve `TRUE` si son iguales y `FALSE` si son distintos.

```{r}
st_crs(uvVald)$epsg == 4326
```

Esto confirma que la capa se encuentra en el sistema de proyección correspondiente. Veamos las otras capas

```{r}
st_crs(lucVald)$epsg == 4326
st_crs(jardinJunji)$epsg == 4326
st_crs(jardinIntegra)$epsg == 4326
```

Esto indica que todas las capas se encuentran en WGS 84.

##### Dato Ráster

De la misma manera, `terra` tiene la función `crs()` que con el argumento `describe = TRUE` y accediendo al código (code) con `$` podemos comparar de la misma manera

```{r}
crs(dem, describe = T)$code == 4326
```

Con esto confirmamos que todas las capas están en la misma proyección.

### Extensión

El objetivo del trabajo está pensado en las unidades vecinales de Valdivia (`uvVald`) pero dentro de los límites de la ciudad (`lucVald`). Visualicemos como se situan todas las capas.


```{r}
#| label: setup-reticulate
#| echo: false
#| message: false
#| warning: false

library(reticulate)
use_condaenv("interactivo", required = TRUE)  # o la ruta completa al python.exe
# para verificar qué Python quedó seleccionado
```

```{python}
#| echo: false
#| message: false
#| warning: false

import folium
import geopandas as gpd
import os
import pandas as pd

integra = gpd.read_file('c:/uni/oit/t1Real/datos/layer_jardines_infantiles_fundacion_integra_20231112011653.shp')
junji = gpd.read_file('c:/uni/oit/t1Real/datos/layer_jardines_infantiles_junji_2024_20240619120021.shp')
luc = gpd.read_file('c:/uni/oit/t1Real/datos/LUC_Valdivia.gpkg')
uv = gpd.read_file('c:/uni/oit/t1Real/datos/Unidad_vecinal_Valdi.gpkg')

integraSimple = integra[['COMUNA', 'NOMBRE', 'MODALIDAD', 'DIRECCION', 'geometry']]
integraSimple['fuente'] = 'INTEGRA'

junjiSimple = junji[['COMUNA', 'NOMBRE', 'MODALIDAD', 'DIRECCION', 'geometry']]
junjiSimple['fuente'] = 'JUNJI'

gdfPuntos = gpd.GeoDataFrame(pd.concat([integraSimple, junjiSimple],ignore_index=True), crs=integraSimple.crs)

geo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in gdfPuntos.geometry]

m = folium.Map(location=[-39.819, -73.245], zoom_start=12, tiles="CartoDB Positron")

grupoJunji = folium.FeatureGroup("Puntos - Junji").add_to(m)
grupoIntegra = folium.FeatureGroup("Puntos - Integra").add_to(m)

for idx, row in gdfPuntos.iterrows():

    coords = [row.geometry.y, row.geometry.x]

    color = 'green' if row['fuente'] == "JUNJI" else 'blue'

    text_html = (
        f"Nombre: {row.NOMBRE}<br>"
        f"Modalidad: {row.MODALIDAD}<br>"
        f"Comuna: {row.COMUNA}<br>"
        f"Direccion: {row.DIRECCION}"
    )

    marker = folium.Marker(
        location = coords,
        popup = text_html,
        icon = folium.Icon(icon = 'school', prefix = 'fa', color=color)
    );

    if row['fuente'] == 'JUNJI':
        marker.add_to(grupoJunji);
    else:
        marker.add_to(grupoIntegra);

fg_luc = folium.FeatureGroup(name="Polígonos - LUC").add_to(m);
fg_uv  = folium.FeatureGroup(name="Polígonos - UV").add_to(m);

style_luc = lambda feat: {
    "fillColor": "orange",
    "color": "darkorange",
    "weight": 1,
    "fillOpacity": 0.35
}
style_uv = lambda feat: {
    "fillColor": "purple",
    "color": "indigo",
    "weight": 1,
    "fillOpacity": 0.25
}

folium.GeoJson(
    data=luc.to_json(),
    name="Limite Urbano Censal",
    style_function=style_luc,
    popup=folium.GeoJsonPopup(fields=list(luc.columns.drop('geometry')))
).add_to(fg_luc);

folium.GeoJson(
    data=uv.to_json(),
    name="Unidad Vecinal",
    style_function=style_uv,
    popup=folium.GeoJsonPopup(fields=list(uv.columns.drop('geometry')))
).add_to(fg_uv);


folium.LayerControl(collapsed=True).add_to(m);

m
```

A primera vista podemos dos desafíos:

1.  La enorme cantidad de establecimientos en jardines infantiles. Esto ocurre ya que ambas campas (Junji e Integra) se encuentran a nivel nacional.

2.  También, el LUC nos provee de los límites a trabajar mientras que las unidades vecinales (que son más grandes), proporciona las "particiones" que tendría la ciudad de Valdivia.

Para ambos problemas se pueden ocupar operaciones espaciales, como por ejemplo, el corte o la superposición. El flujo sería:

1.  Cortar las Unidades Vecinales con las delimitaciones de Valdivia (dadas por el LUC).

2.  A través del LUC de Valdivia, cortar o filtrar ambas capas de jardines infantiles (Junji e Integra).

De este modo, tendríamos todas las capas con las extensiones correspondientes.

#### Recorte 

Hay que diferenciar el tipo de operación espacial que se quiere realizar. 

Primero que nada, se debe reconocer nuestra capa plantilla (`lucVald`), la cual delimitará el espacio de interés. Como precaución validaremos que no existan [errores topológicos](https://www.gisandbeers.com/topologia-principales-errores-en-un-sig/) en las capas. Esto puede hacerse con la función `st_make_valid()` que mantiene polígonos válidos y corrige errores topológicos (como agujeros o superposiciones).
```{r}
lucVald <- st_make_valid(lucVald)
```

De igual manera se puede hacer con la otra capa de polígonos

```{r}
uvVald <- st_make_valid(uvVald)
```

Ahora, en el caso de los puntos, nos interesa obtener los puntos que se encuentran exactamente dentro del Limite Urbano Censal de Valdivia y a su vez, mantener las propiedades de estos (atributos). En el caso de los puntos esto puede verse así

```{r}
junjiVal <- jardinJunji %>%  #<1>
  st_filter(lucVald, #<2>
            .predicate = st_covered_by) #<3>
```
1. Crea el objeto `junjiVal` que es la capa nacional de los jardines JUNJI (`jardinJunji`). A este último se le realizará una operación (en la próxima línea). Esto puede lograrse con la pipa (`%>%`).
2. Filtramos (con la función `st_filter`) la capa original con el LUC (`lucVald`).
3. El método de filtrado es *cubierto por* (`st_covered_by`).

El código anterior se podría traducir a *lenguaje humano* como:

> De la capa de *jardines JUNJI de Chile*, filtra por los que  *están cubiertos por* el Límite Urbano Censal de Valdivia. El resultado de la operación guardalo en `junjiVal`.

Aplicamos la misma lógica para la otra capa

```{r}
integraVal <- jardinIntegra %>%  
  st_filter(lucVald, 
            .predicate = st_covered_by) 
```

Para manejar los datos de la mejor manera, se unirán ambas capas en un solo objeto, claro que diferenciando entre las fuentes de los datos. Primero veamos los atributos de cada capa

```{r}
integraVal %>% glimpse()
junjiVal %>% glimpse()
```

Ambas capas comparten atributos similares como `COMUNA` o `DIRECCION`. Por otro lado, hay atributos que para los objetivos de este trabajo no son necesarios, como latitud, teléfono, etc. Para simplificar esta base de datos compartida nos quedaremos con las siguientes columnas:

*   `Nombre`

*   `Dirección`

*   `Modalidad`

*   `Fuente`: el cual se creará para ver de donde se extrajeron los datos.

Primero se seleccionarán los atributos correspondientes en ambas capas:

```{r}
integraValCopia <- integraVal %>% #<1>
  select(nombre = NOMBRE, #<2>
         direccion = DIRECCION, #<3>
         modalidad = MODALIDAD) %>%  #<3>
  mutate(fuente = "INTEGRA") #<4>

junjiValCopia <- junjiVal %>% #<1>
  select(nombre = NOMBRE, #<2>
         direccion = DIRECCION, #<3>
         modalidad = MODALIDAD) %>%  #<3>
  mutate(fuente = "JUNJI") #<4>
```
1. Aquí, seleccionamos las capa a editar e indicamos que viene una operación con la pipa (`%>%`).
2. Seleccionamos las columnas de interés con la función (`select()`). Además, a través de la expresión `nombre = NOMBRE` se aprovecha de renombrar los nombres originales de las columnas, pasando de `NOMBRE` a `nombre`.
3. De la misma forma, se seleccionan las columnas `DIRECCION` y `MODALIDAD` además de renombrarlas.
4. Con la función `mutate()` *mutamos* la tabla. En este caso, se crea la columna `fuente`, e indicamos que los valores de esa columna es un texto. Dependiendo de donde sea nuestra fuente, tendrá los valores `INTEGRA` o `JUNJI`.

::: {.callout-note}
Es recomendable revisar las capas generadas en cada proceso, ya que este proceso puede ser abstracto y confuso. Puede efectuarse con la función `glimpse()` o simplemente escribiendo el nombre del objeto. Una forma rápida de hacer esto sería por ejemplo

```{r}
#| eval: false

capa_a_analizar %>% glimpse()
```

Donde `capa_a_analizar` es el objeto que se crea, como `junjiValCopia` o `integraValCopia`.
:::

Una vez tengamos ambas capas preparadas podemos unir las capas con la función `bind_rows()`, la cual une tablas por filas. Como requisito, esta función necesita que ambas tablas tengan las mismas columnas (y con los mismos nombres).

```{r}
jardinesValdivia <- integraValCopia %>% 
  bind_rows(junjiValCopia) 
```

En este caso, estamos indicando que la capa `integraValCopia` (que es una tabla), se le una (con `bind_rows()`) la tabla `junjiValCopia`. El resultado de esta operación se guarda en `jardinesValdivia`.


En el caso de las unidades vecinales la opción del filtrado no sirve ya que la capa mantendrá los polígonos que toquen el LUC, pero no los cortará. Esto provocará que la capa de UV sea más grande que el LUC y por ende, no coincidirán espacialmente. Por lo tanto, se debe ocupar la función `st_intersection()`, la cual corta una capa con otra.

```{r}
#| warning: false

uvValdCortado <- uvVald %>% 
  st_intersection(lucVald[0]) %>% #<1>
  st_make_valid() #<2>
```
1. Al LUC (`lucVald`) se le agrega el elemento `[0]` para deseleccionar todas las columnas (o seleccionar ninguna columna). Así, al revisar `uvValdCortado`, solo quedarán las columnas del objeto original, es decir `uvVald`. De no indicar este parámetro, cada polígono de `uvValdCortado` habría quedado con los atributos de la capa original y de la capa plantilla `lucVald`.
2. Repetimos la lógica de evitar errores topológicos.

::: {.callout-note}
El nombre de las variables puede ser confuso, como es en el caso de `uvValdCortado` con `uvVald`. Estos nombres son arbitrarios y usted puede cambiarlo a su conveniencia. Sin embargo, esta guía seguirá empleando los nombres declarados.
:::

Si desea, puede guardar los objetos creados como un archivo `.shp`, lo que es recomendable para no tener que repetir el proceso cada vez que se quiera trabajar con estas capas.

```{r}
#| eval: false

st_write(jardinesValdivia, "jardinesValdivia.shp")
st_write(uvValdCortado, "uvValdCortado.shp")
st_write(junjiVal, "junjiVal.shp") # Opcional
st_write(integraVal, "integraVal.shp") # Opcional
```

```{r}
#| eval: false
#| echo: false
#| output: false

st_write(jardinesValdivia, "datos/jardinesValdivia.shp")
st_write(uvValdCortado, "datos/uvValdCortado.shp")
```

Veamos como quedaron las capas con todo el pre proceso.

```{python}
#| echo: false
#| message: false
#| warning: false

jardines = gpd.read_file('C:/uni/oit/t1Real/datos/jardinesValdivia.shp')
luc = gpd.read_file('C:/uni/oit/t1Real/datos/LUC_Valdivia.gpkg')
uvVal = gpd.read_file('C:/uni/oit/t1Real/datos/uvValdCortado.shp')


geo_df_list = [[point.xy[1][0], point.xy[0][0]] for point in jardines.geometry]

m = folium.Map(location=[-39.819, -73.245], zoom_start=12, tiles="CartoDB Positron")

grupoJunji = folium.FeatureGroup("Puntos - Junji").add_to(m)
grupoIntegra = folium.FeatureGroup("Puntos - Integra").add_to(m)

for idx, row in jardines.iterrows():

    coords = [row.geometry.y, row.geometry.x]

    color = 'green' if row['fuente'] == "JUNJI" else 'blue'

    text_html = (
        f"Nombre: {row.get('nombre', '')}<br>"
        f"Modalidad: {row.get('modalidad', '')}<br>"
        f"Direccion: {row.get('direccion', '')}<br>"
        f"Fuente: {row.get('fuente', '')}"
    )

    marker = folium.Marker(
        location = coords,
        popup = text_html,
        icon = folium.Icon(icon = 'school', prefix = 'fa', color=color)
    );

    if row['fuente'] == 'JUNJI':
        marker.add_to(grupoJunji);
    else:
        marker.add_to(grupoIntegra);

fg_luc = folium.FeatureGroup(name="Polígonos - LUC").add_to(m);
fg_uv  = folium.FeatureGroup(name="Polígonos - UV").add_to(m);

style_luc = lambda feat: {
    "fillColor": "orange",
    "color": "darkorange",
    "weight": 1,
    "fillOpacity": 0.35
}
style_uv = lambda feat: {
    "fillColor": "purple",
    "color": "indigo",
    "weight": 1,
    "fillOpacity": 0.25
}

folium.GeoJson(
    data=luc.to_json(),
    name="Limite Urbano Censal",
    style_function=style_luc,
    popup=folium.GeoJsonPopup(fields=list(luc.columns.drop('geometry')))
).add_to(fg_luc);

folium.GeoJson(
    data=uvVal.to_json(),
    name="Unidad Vecinal",
    style_function=style_uv,
    popup=folium.GeoJsonPopup(fields=list(uvVal.columns.drop('geometry')))
).add_to(fg_uv);


folium.LayerControl(collapsed=True).add_to(m);

m
```







